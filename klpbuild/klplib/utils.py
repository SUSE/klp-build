# SPDX-License-Identifier: GPL-2.0-only
#
# Copyright (C) 2021-2024 SUSE
# Author: Marcos Paulo de Souza <mpdesouza@suse.com>

import io
import logging
import os
from pathlib import Path
import platform
import re
import git

from elftools.common.utils import bytes2str
from elftools.elf.elffile import ELFFile
from elftools.elf.sections import SymbolTableSection

from natsort import natsorted

from klpbuild.klplib.config import get_user_path

ARCH = platform.processor()
ARCHS = ["ppc64le", "s390x", "x86_64"]


# Group all codestreams that share code in a format like bellow:
#   [15.2u10 15.2u11 15.3u10 15.3u12 ]
# Will be converted to:
#   15.2u10-11 15.3u10 15.3u12
# The returned value will be a list of lists, each internal list will
# contain all codestreams which share the same code
def classify_codestreams(cs_list):
    # Group all codestreams that share the same codestream by a new dict
    # divided by the SLE version alone, making it easier to process
    # later
    cs_group = {}
    for cs in cs_list:
        if not isinstance(cs, str):
            cs = cs.full_cs_name()

        prefix, up = cs.split("u")
        if not cs_group.get(prefix, ""):
            cs_group[prefix] = [int(up)]
        else:
            cs_group[prefix].append(int(up))

    ret_list = []
    for cs, ups in cs_group.items():
        if len(ups) == 1:
            ret_list.append(f"{cs}u{ups[0]}")
            continue

        sim = []
        while len(ups):
            if not sim:
                sim.append(ups.pop(0))
                continue

            cur = ups.pop(0)
            last_item = sim[len(sim) - 1]
            if last_item + 1 <= cur:
                sim.append(cur)
                continue

            # they are different, print them
            if len(sim) == 1:
                ret_list.append(f"{cs}u{sim[0]}")
            else:
                ret_list.append(f"{cs}u{sim[0]}-{last_item}")

            sim = [cur]

        # Loop finished, check what's in similar list to print
        if len(sim) == 1:
            ret_list.append(f"{cs}u{sim[0]}")
        elif len(sim) > 1:
            last_item = sim[len(sim) - 1]
            ret_list.append(f"{cs}u{sim[0]}-{last_item}")

    return natsorted(ret_list)


def classify_codestreams_str(cs_list):
    return " ".join(classify_codestreams(cs_list))


def unclassify_codestreams(cs_group, cs_list):
    '''
    Expand the groups generated by classify_codestreams().

    Args:
        cs_group (str): Grouped codestreams e.g: "15.2u10-11 15.3u10 15.3u12"
        cs_list (list): List of codestreams to filter.

    Returns:
        List: The list of codestreams contained in the group.
    '''

    cs_updates = re.findall(r"(\d{1,2}\.\d(?:rt)?u)(\d{1,2})-?(\d{1,2})?", cs_group)
    if not cs_updates or len(cs_updates) != len(cs_group.split()):
        return None

    expanded = set()
    for cs_class in cs_updates:
        cs_base = cs_class[0]
        start = cs_class[1]
        end = cs_class[2]

        if not end:
            expanded.add(f"{cs_base}{start}")
            continue

        for i in range(int(start), int(end) + 1):
            expanded.add(f"{cs_base}{i}")

    return [cs for cs in cs_list if cs.full_cs_name() in expanded]


def is_mod(mod):
    return mod != "vmlinux"


def get_lp_number(lp_name):
    return lp_name.replace("bsc", "")


def get_lp_groups(lp_name, codestreams):
    '''
    Get the codestreams that are contained in each group indicated
    in the ccp/groups file.

    Args:
        lp_name (str): The name of the livepatch.
        codestreams (list): Filtered list of codestreams to group.

    Returns:
        Dict{string:list}: The list of codestreams contained in each group.
    '''

    workdir = get_workdir(lp_name)/"ccp"
    with open(f"{workdir}/groups", "r") as f:
        groups = f.read()

    cs_groups = dict()
    for group in groups.splitlines():
        group = group.strip()

        # Expand group and get all the contained codestreams
        cs_grp = unclassify_codestreams(group, codestreams)
        if not cs_grp:
            logging.debug(f"Skipping codestream group: {group}")
            continue

        cs_groups[group] = cs_grp

    return cs_groups


def get_elf_modinfo_entry(elffile, conf):
    sec = elffile.get_section_by_name(".modinfo")
    if not sec:
        return None

    # Iterate over all info on modinfo section
    for line in bytes2str(sec.data()).split("\0"):
        if line.startswith(conf):
            return line.split("=")[1].strip()

    return ""


def get_elf_object(obj):
    with open(obj, "rb") as f:
        data = f.read()

    return ELFFile(io.BytesIO(data))


# Load the ELF object and return all symbols
def get_all_symbols_from_object(obj, defined):
    syms = []

    for sec in get_elf_object(obj).iter_sections():
        if not isinstance(sec, SymbolTableSection):
            continue

        if sec['sh_entsize'] == 0:
            continue

        for symbol in sec.iter_symbols():
            # Somehow we end up receiving an empty symbol
            if not symbol.name:
                continue
            if str(symbol["st_shndx"]) == "SHN_UNDEF" and not defined:
                syms.append(symbol.name)
            elif str(symbol["st_shndx"]) != "SHN_UNDEF" and defined:
                syms.append(symbol.name)

    return syms


def get_lp_branches(lp_name, git_dir):
    branches = []

    # Filter only the branches related to this BSC
    for r in git.Repo(git_dir).branches:
        if r.name.startswith(lp_name):
            branches.append(r.name)

    return branches


def get_cs_branch(cs, lp_name, git_dir):
    branch_name = ""

    for branch in get_lp_branches(lp_name, git_dir):
        # Check if the codestream is a rt one, and if yes, apply the correct
        # separator later on
        if cs.rt and "rt" not in branch:
            continue

        separator = "u"
        if cs.rt:
            separator = "rtu"

        # First check if the branch has more than code stream sharing
        # the same code
        for b in branch.replace(lp_name + "_", "").split("_"):
            # Only check the branches that are the same type of the branch
            # being searched. Only check RT branches if the codestream is a
            # RT one.
            if cs.rt and "rtu" not in b:
                continue

            if not cs.rt and "rtu" in b:
                continue

            sle, u = b.split(separator)
            if f"{cs.sle}.{cs.sp}" != f"{sle}":
                continue

            # Get codestreams interval
            up = u
            down = u
            if "-" in u:
                down, up = u.split("-")

            # Codestream between the branch codestream interval
            if cs.update >= int(down) and cs.update <= int(up):
                branch_name = branch
                break

            # At this point we found a match for our codestream in
            # codestreams.json, but we may have a more specialized git
            # branch later one, like:
            # bsc1197597_12.4u21-25_15.0u25-28
            # bsc1197597_15.0u25-28
            # Since 15.0 SLE uses a different kgraft-patches branch to
            # be built on. In this case, we continue to loop over the
            # other branches.

    return branch_name


def check_module_unsupported(arch, mod_path):
    elffile = get_elf_object(get_datadir(arch)/mod_path)
    return "no" == get_elf_modinfo_entry(elffile, "supported")


def filter_codestreams(lp_filter, cs_list, verbose=False):
    if not lp_filter:
        return cs_list

    if verbose:
        logging.info("Checking filter...")

    result = []
    filtered = []
    for cs in cs_list:
        name = cs.full_cs_name()
        if re.match(lp_filter, name):
            result.append(cs)
        else:
            filtered.append(name)

    if verbose and filtered:
        logging.info("Skipping codestreams:")
        logging.info("\t%s", classify_codestreams_str(filtered))

    return result


def affected_archs(cs_list):
    conf_archs = set()
    for cs in cs_list:
        for val in cs.configs.values():
            conf_archs.update(val)

    return sorted(conf_archs)


def get_mail():
    git_data = git.GitConfigParser()
    user = git_data.get_value("user", "name")
    email = git_data.get_value("user", "email")

    return user, email

def fix_mod_string(mod):
    if not is_mod(mod):
        return ""

    # Modules like snd-pcm needs to be replaced by snd_pcm in LP_MODULE
    # and in kallsyms lookup
    return os.path.basename(mod.replace("-", "_"))


def get_fname(src_name):
    """
    Get the source name and transforms into a string version of it, without the extension.

    Returns:
        String: The same src_name string without externsion and hyphens replaced by underscores.
    """

    return str(Path(src_name).with_suffix("")).replace("-", "_")


def get_workdir(lp_name):
    """
    Get the working directory for a given livepatch name.

    Args:
        lp_name (str): The name of the livepatch.

    Returns:
        Path: The full path to the livepatch file.
    """
    return get_user_path('work_dir')/lp_name


def get_datadir(arch=""):
    """
    Get the data directory.

    Returns:
        Path: The full path to the livepatch file.
    """
    if arch:
        assert arch in ARCHS
    data_dir = get_user_path('data_dir')
    return data_dir/arch if arch else data_dir


def get_tests_path(lp_name):
    """
    Retrieves the path of the test script associated with a given live patch name.

    Args:
        lp_name (str): The live patch name to search for the test script.

    Returns:
        Path: The path to the test script or directory containing it, or None
              if it doesn't exist.
    """
    kgr_path = get_user_path('kgr_patches_tests_dir', isopt=True)
    if not kgr_path:
        return None

    test_sh = kgr_path/(lp_name+"_test_script.sh")
    if test_sh.is_file():
        return test_sh

    test_dir_sh = kgr_path/lp_name/"test_script.sh"
    if test_dir_sh.is_file():
        # For more complex tests we support using a directory containing
        # as much files as needed. A `test_script.sh` is still required
        # as an entry point.
        return Path(test_dir_sh).parent

    logging.warning("No testscript found for %s", lp_name)
    return None


def in_test_mode():
    return os.getenv("TEST_MODE", 'n') == 'y'


def is_cve_valid(cve):
    # Support CVEs from 2020 up to 2029
    return re.match(r"^202[0-9]-[0-9]{4,7}$", cve)
