{% include 'header.j2' %}

{% if config is not none %}
#if IS_ENABLED({{ config }})

{% if mod is defined %}
#if !IS_MODULE({{ config }})
#error "Live patch supports only CONFIG=m"
#endif
{% endif %}
{% endif %}

{% if inc_src_file is not none -%}
{% include inc_src_file %}
{% endif %}




{% if mod is defined %}
#define LP_MODULE "{{ mod }}"
{% endif %}

#include <linux/kernel.h>
{% if mod is defined %}
#include <linux/module.h>
{% endif %}
#include "livepatch_bsc{{ bsc_num }}.h"
#include "../kallsyms_relocs.h"

static struct klp_kallsyms_reloc klp_funcs[] = {
{% if inc_exts_file is not none -%}
{% include inc_exts_file %}

{% elif mod is defined %}
	{ "", (void *)&, LP_MODULE },
{% else %}
	{ "", (void *)&},
{% endif %}
};

{% if mod is defined %}
static int {{ fname }}_module_notify(struct notifier_block *nb,
					unsigned long action, void *data)
{
	struct module *mod = data;
	int ret;

	if (action != MODULE_STATE_COMING || strcmp(mod->name, LP_MODULE))
		return 0;
{% if mod_mutex is defined %}
	mutex_lock(&module_mutex);
	ret = __klp_resolve_kallsyms_relocs(klp_funcs, ARRAY_SIZE(klp_funcs));
	mutex_unlock(&module_mutex);
{% else %}
	ret = klp_resolve_kallsyms_relocs(klp_funcs, ARRAY_SIZE(klp_funcs));
{% endif %}

	WARN(ret, "%s: delayed kallsyms lookup failed. System is broken and can crash.\n",
		__func__);

	return ret;
}

static struct notifier_block module_nb = {
	.notifier_call = {{ fname }}_module_notify,
	.priority = INT_MIN+1,
};

{% endif -%}

int {{ fname }}_init(void)
{
{% if mod is defined %}
	int ret;
{% if mod_mutex is defined %}

	mutex_lock(&module_mutex);
	if (find_module(LP_MODULE)) {
		ret = __klp_resolve_kallsyms_relocs(klp_funcs,
						    ARRAY_SIZE(klp_funcs));
		if (ret)
			goto out;
	}

	ret = register_module_notifier(&module_nb);
out:
	mutex_unlock(&module_mutex);
	return ret;
{% else %}
	struct module *mod;

	ret = klp_kallsyms_relocs_init();
	if (ret)
		return ret;

	ret = register_module_notifier(&module_nb);
	if (ret)
		return ret;

	rcu_read_lock_sched();
	mod = (*klpe_find_module)(LP_MODULE);
	if (!try_module_get(mod))
		mod = NULL;
	rcu_read_unlock_sched();

	if (mod) {
		ret = klp_resolve_kallsyms_relocs(klp_funcs,
						ARRAY_SIZE(klp_funcs));
	}

	if (ret)
		unregister_module_notifier(&module_nb);
	module_put(mod);

	return ret;
{% endif %}
{% else %}
{% if mod_mutex is defined %}
	return __klp_resolve_kallsyms_relocs(klp_funcs, ARRAY_SIZE(klp_funcs));
{% else %}
	return klp_resolve_kallsyms_relocs(klp_funcs, ARRAY_SIZE(klp_funcs));
{% endif %}
{% endif %}
}

{% if mod is defined %}
void {{ fname }}_cleanup(void)
{
	unregister_module_notifier(&module_nb);
}
{% endif -%}
{% if config is not none %}

#endif /* IS_ENABLED({{ config }}) */
{% endif -%}
